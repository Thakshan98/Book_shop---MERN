{"ast":null,"code":"'use strict';\n\nconst Mixed = require('../schema/mixed');\n\nconst deepEqual = require('../utils').deepEqual;\n\nconst get = require('../helpers/get');\n\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\n\nconst util = require('util');\n\nconst specialProperties = require('../helpers/specialProperties');\n\nconst populateModelSymbol = require('../helpers/symbols').populateModelSymbol;\n/*!\n * ignore\n */\n\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (v != null && v.constructor.name === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n\n    super(v);\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  get(key, options) {\n    options = options || {};\n\n    if (options.getters === false) {\n      return super.get(key);\n    }\n\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  set(key, value) {\n    checkValidKey(key);\n    value = handleSpreadDoc(value); // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({\n        key: key,\n        value: value\n      });\n      return;\n    }\n\n    const fullPath = this.$__path + '.' + key;\n    const populated = this.$__parent != null && this.$__parent.$__ ? this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) : null;\n    const priorVal = this.get(key);\n\n    if (populated != null) {\n      if (value.$__ == null) {\n        value = new populated.options[populateModelSymbol](value);\n      }\n\n      value.$__.wasPopulated = true;\n    } else {\n      try {\n        value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key));\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath, error);\n          return;\n        }\n\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n\n    const parent = this.$__parent;\n\n    if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {\n      parent.markModified(this.$__path + '.' + key);\n    }\n  }\n\n  delete(key) {\n    this.set(key, undefined);\n    super.delete(key);\n  }\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (get(options, 'flattenMaps')) {\n      const ret = {};\n      const keys = this.keys();\n\n      for (const key of keys) {\n        ret[key] = this.get(key);\n      }\n\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  toJSON() {\n    const ret = {};\n    const keys = this.keys();\n\n    for (const key of keys) {\n      ret[key] = this.get(key);\n    }\n\n    return ret;\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n\n    this.$__deferred = null;\n  }\n\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n/*!\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;","map":{"version":3,"sources":["C:/Users/Thakshan/Desktop/BookCorner/node_modules/mongoose/lib/types/map.js"],"names":["Mixed","require","deepEqual","get","handleSpreadDoc","util","specialProperties","populateModelSymbol","MongooseMap","Map","constructor","v","path","doc","schemaType","name","Object","keys","reduce","arr","key","concat","$__parent","$__","$__path","$__schemaType","$__runDeferred","$init","value","checkValidKey","set","$isSingleNested","$basePath","$__set","options","getters","applyGetters","$__deferred","push","fullPath","populated","priorVal","wasPopulated","applySetters","error","invalidate","parent","markModified","delete","undefined","toBSON","toObject","ret","toJSON","inspect","keyValueObject","custom","defineProperty","prototype","enumerable","writable","configurable","keyType","TypeError","startsWith","Error","includes","has","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Mixed = require('../schema/mixed');\nconst deepEqual = require('../utils').deepEqual;\nconst get = require('../helpers/get');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst util = require('util');\nconst specialProperties = require('../helpers/specialProperties');\n\nconst populateModelSymbol = require('../helpers/symbols').populateModelSymbol;\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (v != null && v.constructor.name === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  get(key, options) {\n    options = options || {};\n    if (options.getters === false) {\n      return super.get(key);\n    }\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  set(key, value) {\n    checkValidKey(key);\n    value = handleSpreadDoc(value);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({ key: key, value: value });\n      return;\n    }\n\n    const fullPath = this.$__path + '.' + key;\n    const populated = this.$__parent != null && this.$__parent.$__ ?\n      this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) :\n      null;\n    const priorVal = this.get(key);\n\n    if (populated != null) {\n      if (value.$__ == null) {\n        value = new populated.options[populateModelSymbol](value);\n      }\n      value.$__.wasPopulated = true;\n    } else {\n      try {\n        value = this.$__schemaType.\n          applySetters(value, this.$__parent, false, this.get(key));\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath, error);\n          return;\n        }\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n\n    const parent = this.$__parent;\n    if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {\n      parent.markModified(this.$__path + '.' + key);\n    }\n  }\n\n  delete(key) {\n    this.set(key, undefined);\n    super.delete(key);\n  }\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (get(options, 'flattenMaps')) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = this.get(key);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  toJSON() {\n    const ret = {};\n    const keys = this.keys();\n    for (const key of keys) {\n      ret[key] = this.get(key);\n    }\n    return ret;\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n\n    this.$__deferred = null;\n  }\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/*!\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;\n"]},"metadata":{},"sourceType":"script"}