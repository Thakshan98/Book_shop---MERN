{"ast":null,"code":"'use strict';\n\nconst PromiseProvider = require('../promise_provider');\n\nconst emittedSymbol = Symbol.for('mongoose:emitted');\n\nmodule.exports = function promiseOrCallback(callback, fn, ee) {\n  if (typeof callback === 'function') {\n    return fn(function (error) {\n      if (error != null) {\n        if (ee != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n\n        try {\n          callback(error);\n        } catch (error) {\n          return process.nextTick(() => {\n            throw error;\n          });\n        }\n\n        return;\n      }\n\n      callback.apply(this, arguments);\n    });\n  }\n\n  const Promise = PromiseProvider.get();\n  return new Promise((resolve, reject) => {\n    fn(function (error, res) {\n      if (error != null) {\n        if (ee != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n\n        return reject(error);\n      }\n\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n\n      resolve(res);\n    });\n  });\n};","map":{"version":3,"sources":["C:/Users/Thakshan/Desktop/BookCorner/node_modules/mongoose/lib/helpers/promiseOrCallback.js"],"names":["PromiseProvider","require","emittedSymbol","Symbol","for","module","exports","promiseOrCallback","callback","fn","ee","error","listeners","length","emit","process","nextTick","apply","arguments","Promise","get","resolve","reject","res","Array","prototype","slice","call"],"mappings":"AAAA;;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAAC,qBAAD,CAA/B;;AAEA,MAAMC,aAAa,GAAGC,MAAM,CAACC,GAAP,CAAW,kBAAX,CAAtB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,iBAAT,CAA2BC,QAA3B,EAAqCC,EAArC,EAAyCC,EAAzC,EAA6C;AAC5D,MAAI,OAAOF,QAAP,KAAoB,UAAxB,EAAoC;AAClC,WAAOC,EAAE,CAAC,UAASE,KAAT,EAAgB;AACxB,UAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAID,EAAE,IAAI,IAAN,IAAcA,EAAE,CAACE,SAAH,CAAa,OAAb,EAAsBC,MAAtB,GAA+B,CAA7C,IAAkD,CAACF,KAAK,CAACT,aAAD,CAA5D,EAA6E;AAC3ES,UAAAA,KAAK,CAACT,aAAD,CAAL,GAAuB,IAAvB;AACAQ,UAAAA,EAAE,CAACI,IAAH,CAAQ,OAAR,EAAiBH,KAAjB;AACD;;AACD,YAAI;AACFH,UAAAA,QAAQ,CAACG,KAAD,CAAR;AACD,SAFD,CAEE,OAAOA,KAAP,EAAc;AACd,iBAAOI,OAAO,CAACC,QAAR,CAAiB,MAAM;AAC5B,kBAAML,KAAN;AACD,WAFM,CAAP;AAGD;;AACD;AACD;;AACDH,MAAAA,QAAQ,CAACS,KAAT,CAAe,IAAf,EAAqBC,SAArB;AACD,KAhBQ,CAAT;AAiBD;;AAED,QAAMC,OAAO,GAAGnB,eAAe,CAACoB,GAAhB,EAAhB;AAEA,SAAO,IAAID,OAAJ,CAAY,CAACE,OAAD,EAAUC,MAAV,KAAqB;AACtCb,IAAAA,EAAE,CAAC,UAASE,KAAT,EAAgBY,GAAhB,EAAqB;AACtB,UAAIZ,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAID,EAAE,IAAI,IAAN,IAAcA,EAAE,CAACE,SAAH,CAAa,OAAb,EAAsBC,MAAtB,GAA+B,CAA7C,IAAkD,CAACF,KAAK,CAACT,aAAD,CAA5D,EAA6E;AAC3ES,UAAAA,KAAK,CAACT,aAAD,CAAL,GAAuB,IAAvB;AACAQ,UAAAA,EAAE,CAACI,IAAH,CAAQ,OAAR,EAAiBH,KAAjB;AACD;;AACD,eAAOW,MAAM,CAACX,KAAD,CAAb;AACD;;AACD,UAAIO,SAAS,CAACL,MAAV,GAAmB,CAAvB,EAA0B;AACxB,eAAOQ,OAAO,CAACG,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BT,SAA3B,EAAsC,CAAtC,CAAD,CAAd;AACD;;AACDG,MAAAA,OAAO,CAACE,GAAD,CAAP;AACD,KAZC,CAAF;AAaD,GAdM,CAAP;AAeD,CAtCD","sourcesContent":["'use strict';\n\nconst PromiseProvider = require('../promise_provider');\n\nconst emittedSymbol = Symbol.for('mongoose:emitted');\n\nmodule.exports = function promiseOrCallback(callback, fn, ee) {\n  if (typeof callback === 'function') {\n    return fn(function(error) {\n      if (error != null) {\n        if (ee != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n        try {\n          callback(error);\n        } catch (error) {\n          return process.nextTick(() => {\n            throw error;\n          });\n        }\n        return;\n      }\n      callback.apply(this, arguments);\n    });\n  }\n\n  const Promise = PromiseProvider.get();\n\n  return new Promise((resolve, reject) => {\n    fn(function(error, res) {\n      if (error != null) {\n        if (ee != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n        return reject(error);\n      }\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n      resolve(res);\n    });\n  });\n};"]},"metadata":{},"sourceType":"script"}