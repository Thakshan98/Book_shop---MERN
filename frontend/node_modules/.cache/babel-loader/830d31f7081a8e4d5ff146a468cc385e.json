{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\n\nconst $type = require('./operators/type');\n\nconst MongooseError = require('../error/mongooseError');\n\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst CastError = SchemaType.CastError;\n\nconst Mixed = require('./mixed');\n\nconst arrayDepth = require('../helpers/arrayDepth');\n\nconst cast = require('../cast');\n\nconst get = require('../helpers/get');\n\nconst isOperator = require('../helpers/query/isOperator');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst castToNumber = require('./operators/helpers').castToNumber;\n\nconst geospatial = require('./operators/geospatial');\n\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    } // support { type: 'String' }\n\n\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    this.$embeddedSchemaType = this.caster;\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      let arr = [];\n\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      } // Leave it up to `cast()` to convert the array\n\n\n      return arr;\n    };\n\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaArray.schemaName = 'Array';\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\nSchemaArray.defaultOptions = {};\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaArray.set = SchemaType.set;\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  } // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n\n\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n\n    break;\n  }\n\n  arr.caster.enum.apply(arr.caster, arguments);\n  return this;\n};\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor instanceof SchemaArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n\n    while (arr != null && arr instanceof SchemaArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    } // No need to wrap empty arrays\n\n\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      } // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n\n\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substr(0, this.path.lastIndexOf('.')) : null;\n\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    const isPopulated = doc != null && doc.$__ != null && doc.populated(this.path);\n\n    if (isPopulated) {\n      return value;\n    }\n\n    if (this.caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          // Special case: number arrays disallow undefined.\n          // Re: gh-840\n          // See commit 1298fe92d2c790a90594bd08199e45a4a09162a6\n          if (this.caster.instance === 'Number' && value[i] === void 0) {\n            throw new MongooseError('Mongoose number arrays disallow storing undefined');\n          }\n\n          const opts = {};\n\n          if (options != null && options.arrayPath != null) {\n            opts.arrayPath = options.arrayPath + '.' + i;\n          } else if (this.caster._arrayPath != null) {\n            opts.arrayPath = this.caster._arrayPath.slice(0, -2) + '.' + i;\n          }\n\n          value[i] = this.caster.cast(value[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n/*!\n * Ignore\n */\n\n\nSchemaArray.prototype.discriminator = function (name, schema) {\n  let arr = this; // eslint-disable-line consistent-this\n\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n\n  return arr.discriminator(name, schema);\n};\n/*!\n * ignore\n */\n\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  return schematype;\n};\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);\n\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function (v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n\n    return v;\n  }, this);\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  } // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n\n\n  const discriminatorKey = get(this, 'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\n\nhandle.$or = handle.$and = function (val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  const ret = [];\n\n  for (const obj of val) {\n    ret.push(cast(this.casterConstructor.schema, obj));\n  }\n\n  return ret;\n};\n\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery; // `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\n\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"sources":["C:/Users/Thakshan/Desktop/BookCorner/node_modules/mongoose/lib/schema/array.js"],"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","arrayDepth","cast","get","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","clone","Object","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","$embeddedSchemaType","path","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","arr","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","instance","Error","apply","arguments","applyGetters","scope","ref","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","length","valueDepth","min","max","containsNonArrayItem","i","prev","Array","l","isArray","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substr","lastIndexOf","isMongooseArray","isPopulated","$__","populated","opts","_arrayPath","slice","e","kind","inspect","markModified","discriminator","assign","schematype","validators","requiredValidator","undefined","castForQuery","$conditional","handler","val","$conditionalHandlers","Constructor","discriminators","discriminatorKey","constructorByValue","proto","method","setters","reverse","forEach","setter","map","v","isObject","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","$and","TypeError","ret","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$ne","$regex","$nin","$in","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst get = require('../helpers/get');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    this.$embeddedSchemaType = this.caster;\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      let arr = [];\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n  arr.caster.enum.apply(arr.caster, arguments);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor instanceof SchemaArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr instanceof SchemaArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substr(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    const isPopulated = doc != null && doc.$__ != null && doc.populated(this.path);\n    if (isPopulated) {\n      return value;\n    }\n\n    if (this.caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          // Special case: number arrays disallow undefined.\n          // Re: gh-840\n          // See commit 1298fe92d2c790a90594bd08199e45a4a09162a6\n          if (this.caster.instance === 'Number' && value[i] === void 0) {\n            throw new MongooseError('Mongoose number arrays disallow storing undefined');\n          }\n          const opts = {};\n          if (options != null && options.arrayPath != null) {\n            opts.arrayPath = options.arrayPath + '.' + i;\n          } else if (this.caster._arrayPath != null) {\n            opts.arrayPath = this.caster._arrayPath.slice(0, -2) + '.' + i;\n          }\n          value[i] = this.caster.cast(value[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function(name, schema) {\n  let arr = this; // eslint-disable-line consistent-this\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = get(this,\n    'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = handle.$and = function(val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  const ret = [];\n  for (const obj of val) {\n    ret.push(cast(this.casterConstructor.schema, obj));\n  }\n\n  return ret;\n};\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"]},"metadata":{},"sourceType":"script"}