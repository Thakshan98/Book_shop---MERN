{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\n\nconst get = require('./helpers/get');\n\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst clone = require('./helpers/clone');\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n\n  return pop;\n};\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []); // lean options should trickle through all queries\n\n  if (options.lean != null) {\n    pop.filter(p => get(p, 'options.lean') == null).forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  return pop;\n};\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\n\n\nexports.createModel = function createModel(model, doc, fields, userProvidedFields) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model, value);\n\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  });\n};\n/*!\n * ignore\n */\n\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n\n      const field = fields[keys[keyIndex]]; // Skip `$meta` and `$slice`\n\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n\n      exclude = !field;\n      break;\n    }\n  } // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n\n    case false:\n      if (schema && schema.paths['_id'] && schema.paths['_id'].options && schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n\n      break;\n\n    case undefined:\n      if (fields == null) {\n        break;\n      } // Any leftover plus paths must in the schema, so delete them (gh-7017)\n\n\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      } // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n\n\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = ''); // avoid recursion\n\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      const addedPath = analyzePath(path, type);\n\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      } // nested schemas\n\n\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path); // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n\n\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath]; // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    } // check for parent exclusions\n\n\n    const pieces = path.split('.');\n    let cur = '';\n\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    } // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n\n\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n    option.options.lean = val;\n  };\n}\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    const mongooseResult = Object.assign({}, res.result);\n\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n\n    return callback(null, mongooseResult);\n  };\n};","map":{"version":3,"sources":["C:/Users/Thakshan/Desktop/BookCorner/node_modules/mongoose/lib/queryhelpers.js"],"names":["checkEmbeddedDiscriminatorKeyProjection","require","get","getDiscriminatorByValue","isDefiningProjection","clone","exports","preparePopulationOptions","query","options","_populate","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","preparePopulationOptionsMQ","_mongooseOptions","session","path","projection","_fieldsForExec","_queryProjection","createModel","model","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","skipId","isNew","willInit","exclude","keyIndex","length","field","selected","excluded","stack","analyzeSchema","fieldName","paths","select","_id","startsWith","prefix","indexOf","push","addedPaths","eachPath","type","addedPath","analyzePath","_addedPaths","plusPath","hasPlusPath","pieces","split","cur","i","val","option","handleDeleteWriteOpResult","callback","_handleDeleteWriteOpResult","error","res","mongooseResult","assign","result","deletedCount","n"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  });\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let keyIndex;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    keyIndex = keys.length;\n\n    while (keyIndex--) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      const addedPath = analyzePath(path, type);\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n    option.options.lean = val;\n  };\n}\n\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\nexports.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {\n  return function _handleDeleteWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    const mongooseResult = Object.assign({}, res.result);\n    if (get(res, 'result.n', null) != null) {\n      mongooseResult.deletedCount = res.result.n;\n    }\n    if (res.deletedCount != null) {\n      mongooseResult.deletedCount = res.deletedCount;\n    }\n    return callback(null, mongooseResult);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}