{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Kareem = require('kareem');\n\nconst MongooseError = require('./error/mongooseError');\n\nconst SchemaType = require('./schematype');\n\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\n\nconst VirtualOptions = require('./options/VirtualOptions');\n\nconst VirtualType = require('./virtualtype');\n\nconst addAutoId = require('./helpers/schema/addAutoId');\n\nconst applyTimestampsToChildren = require('./helpers/update/applyTimestampsToChildren');\n\nconst applyTimestampsToUpdate = require('./helpers/update/applyTimestampsToUpdate');\n\nconst arrayParentSymbol = require('./helpers/symbols').arrayParentSymbol;\n\nconst get = require('./helpers/get');\n\nconst getIndexes = require('./helpers/schema/getIndexes');\n\nconst handleTimestampOption = require('./helpers/schema/handleTimestampOption');\n\nconst merge = require('./helpers/schema/merge');\n\nconst mpath = require('mpath');\n\nconst readPref = require('./driver').get().ReadPreference;\n\nconst symbols = require('./schema/symbols');\n\nconst util = require('util');\n\nconst utils = require('./utils');\n\nconst validateRef = require('./helpers/populate/validateRef');\n\nlet MongooseTypes;\n\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').middlewareFunctions;\n\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\n\nconst hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set());\nlet id = 0;\n/**\n * Schema constructor.\n *\n * ####Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * ####Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [capped](/docs/guide.html#capped): bool - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [typePojoToMixed](/docs/guide.html#typePojoToMixed) - boolean - defaults to true. Determines whether a type set to a POJO becomes a Mixed path or a Subdocument\n * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [storeSubdocValidationError](/docs/guide.html#storeSubdocValidationError): boolean - Defaults to true. If false, Mongoose will wrap validation errors in single nested document subpaths into a single validation error on the single nested subdoc's path.\n *\n * ####Options for Nested Schemas:\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * ####Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.methodOptions = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n  this.plugins = []; // For internal debugging. Do not use this to try to save a schema in MDB.\n\n  this.$id = ++id;\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options); // build paths\n\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  } // check if _id's value is a subdocument (gh-2276)\n\n\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id); // ensure the documents get an auto _id unless disabled\n\n\n  const auto_id = !this.paths['_id'] && !this.options.noId && this.options._id && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n/*!\n * Create virtual properties with alias field\n */\n\n\nfunction aliasFields(schema, paths) {\n  paths = paths || Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const options = get(schema.paths[path], 'options');\n\n    if (options == null) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    const alias = options.alias;\n\n    if (!alias) {\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n    schema.virtual(alias).get(function (p) {\n      return function () {\n        if (typeof this.get === 'function') {\n          return this.get(p);\n        }\n\n        return this[p];\n      };\n    }(prop)).set(function (p) {\n      return function (v) {\n        return this.set(p, v);\n      };\n    }(prop));\n  }\n}\n/*!\n * Inherit from EventEmitter.\n */\n\n\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n/**\n * The original object passed to the schema constructor\n *\n * ####Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * ####Example:\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n/**\n * Schema as a tree\n *\n * ####Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n/**\n * Returns a deep copy of the schema\n *\n * ####Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function () {\n  const s = new Schema({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function (f) {\n    return f;\n  });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n  s.childSchemas = gatherChildSchemas(s);\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases); // Bubble up `init` for backwards compat\n\n  s.on('init', v => this.emit('init', v));\n  return s;\n};\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * ####Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {Array} paths list of paths to pick\n * @param {Object} [options] options to pass to the schema constructor. Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\n\nSchema.prototype.pick = function (paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' + 'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({\n        [path]: get(this.tree, path)\n      });\n    } else {\n      const schematype = this.path(path);\n\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n\n      newSchema.add({\n        [path]: schematype\n      });\n    }\n  }\n\n  return newSchema;\n};\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\n\nSchema.prototype.defaultOptions = function (options) {\n  if (options && options.safe === false) {\n    options.safe = {\n      w: 0\n    };\n  }\n\n  if (options && options.safe && options.safe.w === 0) {\n    // if you turn off safe writes, then versioning goes off as well\n    options.versionKey = false;\n  }\n\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n  const baseOptions = get(this, 'base.options', {});\n  options = utils.options({\n    strict: 'strict' in baseOptions ? baseOptions.strict : true,\n    strictQuery: 'strictQuery' in baseOptions ? baseOptions.strictQuery : false,\n    bufferCommands: true,\n    capped: false,\n    // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    discriminatorKey: '__t',\n    minimize: true,\n    autoIndex: null,\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    noId: false,\n    // deprecated, use { _id: false }\n    _id: true,\n    noVirtualId: false,\n    // deprecated, use { id: false }\n    id: true,\n    typeKey: 'type',\n    typePojoToMixed: 'typePojoToMixed' in baseOptions ? baseOptions.typePojoToMixed : true\n  }, utils.clone(options));\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * ####Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema) {\n    merge(this, obj);\n    return this;\n  } // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n\n\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n\n  for (const key of keys) {\n    const fullPath = prefix + key;\n\n    if (obj[key] == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath + '`, got value \"' + obj[key] + '\"');\n    } // Retain `_id: false` but don't set it as a path, re: gh-8274.\n\n\n    if (key === '_id' && obj[key] === false) {\n      continue;\n    }\n\n    if (obj[key] instanceof VirtualType) {\n      this.virtual(obj[key]);\n      continue;\n    }\n\n    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath + '`, got value \"' + obj[key][0] + '\"');\n    }\n\n    if (!(utils.isPOJO(obj[key]) || obj[key] instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n\n      this.path(prefix + key, obj[key]);\n    } else if (Object.keys(obj[key]).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n\n      this.path(fullPath, obj[key]); // mixed type\n    } else if (!obj[key][this.options.typeKey] || this.options.typeKey === 'type' && obj[key].type.type) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object { last: { name: String }}\n      this.nested[fullPath] = true;\n      this.add(obj[key], fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      if (!this.options.typePojoToMixed && utils.isPOJO(obj[key][this.options.typeKey])) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        } // Propage `typePojoToMixed` to implicitly created schemas\n\n\n        const opts = {\n          typePojoToMixed: false\n        };\n\n        const _schema = new Schema(obj[key][this.options.typeKey], opts);\n\n        const schemaWrappedPath = Object.assign({}, obj[key], {\n          [this.options.typeKey]: _schema\n        });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        }\n\n        this.path(prefix + key, obj[key]);\n      }\n    }\n  }\n\n  const addedKeys = Object.keys(obj).map(key => prefix ? prefix + key : key);\n  aliasFields(this, addedKeys);\n  return this;\n};\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are rejected in schema declarations\n * because they conflict with Mongoose functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will throw\n * an error.\n *\n * - _posts\n * - _pres\n * - collection\n * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\nconst reserved = Schema.reserved; // Core object\n\nreserved['prototype'] = // EventEmitter\nreserved.emit = reserved.listeners = reserved.on = reserved.removeListener = // document properties and functions\nreserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.schema = reserved.toObject = reserved.validate = 1;\n/*!\n * Document keys to print warnings for\n */\n\nconst warnings = {};\nwarnings.increment = '`increment` should not be used as a schema path name ' + 'unless you have disabled versioning.';\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * ####Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function (path, obj) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (obj === undefined) {\n    let schematype = _getPath(this, path, cleanPath);\n\n    if (schematype != null) {\n      return schematype;\n    } // Look for maps\n\n\n    const mapPath = getMapPath(this, path);\n\n    if (mapPath != null) {\n      return mapPath;\n    } // Look if a parent of this path is mixed\n\n\n    schematype = this.hasMixedParent(cleanPath);\n\n    if (schematype != null) {\n      return schematype;\n    } // subpaths?\n\n\n    return /\\.\\d+\\.?.*$/.test(path) ? getPositionalPath(this, path) : undefined;\n  } // some path names conflict with document methods\n\n\n  const firstPieceOfPath = path.split('.')[0];\n\n  if (reserved[firstPieceOfPath]) {\n    throw new Error('`' + firstPieceOfPath + '` may not be used as a schema pathname');\n  }\n\n  if (warnings[path]) {\n    console.log('WARN: ' + warnings[path]);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  } // update the tree\n\n\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. ' + 'Parent path `' + fullPath + '` already set to type ' + branch[sub].name + '.';\n      throw new Error(msg);\n    }\n\n    branch = branch[sub];\n  }\n\n  branch[last] = utils.clone(obj);\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n    let _mapType = {\n      type: {}\n    };\n\n    if (utils.hasUserDefinedProperty(obj, 'of')) {\n      const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, this.options.typeKey);\n      _mapType = isInlineSchema ? new Schema(obj.of) : obj.of;\n    }\n\n    this.paths[mapPath] = this.interpretAsType(mapPath, _mapType, this.options);\n    schemaType.$__schemaType = this.paths[mapPath];\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key in schemaType.schema.paths) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n\n    for (const key in schemaType.schema.singleNestedPaths) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.singleNestedPaths[key];\n    }\n\n    for (const key in schemaType.schema.subpaths) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.subpaths[key];\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n    const toAdd = [];\n\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$'; // Skip arrays of document arrays\n\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType = _schemaType.caster.clone();\n      }\n\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.subpaths[path + '.' + key] = schemaType.schema.paths[key];\n      schemaType.schema.paths[key].$isUnderneathDocArray = true;\n    }\n\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.subpaths[path + '.' + key] = schemaType.schema.subpaths[key];\n      schemaType.schema.subpaths[key].$isUnderneathDocArray = true;\n    }\n\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.subpaths[path + '.' + key] = schemaType.schema.singleNestedPaths[key];\n      schemaType.schema.singleNestedPaths[key].$isUnderneathDocArray = true;\n    }\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({\n        schema: schematype.schema,\n        model: schematype.caster\n      });\n    }\n  }\n\n  return childSchemas;\n}\n/*!\n * ignore\n */\n\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath)) {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n/*!\n * ignore\n */\n\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n/*!\n * ignore\n */\n\n\nfunction getMapPath(schema, path) {\n  for (const _path of Object.keys(schema.paths)) {\n    if (!_path.includes('.$*')) {\n      continue;\n    }\n\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\nSchema.prototype.interpretAsType = function (path, obj, options) {\n  if (obj instanceof SchemaType) {\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  } // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n\n\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  } // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n\n\n  let type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type) ? obj[options.typeKey] : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = type === Array || type === 'array' ? obj.cast : type[0];\n\n    if (cast && cast.instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n\n    if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast[options.typeKey] || options.typeKey === 'type' && cast.type.type) && utils.isPOJO(cast)) {\n      if (Object.keys(cast).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = {\n          minimize: options.minimize\n        };\n\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        } // propagate 'strict' option to child schema\n\n\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n\n        if (options.hasOwnProperty('typePojoToMixed')) {\n          childSchemaOptions.typePojoToMixed = options.typePojoToMixed;\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions && Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(cast, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n      name = typeof type === 'string' ? type : type.schemaName || utils.getFunctionName(type);\n\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' + `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` + 'See http://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Embedded(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  } // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n\n\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` + `a valid type at path \\`${path}\\`. See ` + 'http://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  return new MongooseTypes[name](path, obj);\n};\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * ####Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\n\nSchema.prototype.eachPath = function (fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * ####Example:\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * ####Example:\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\n\nSchema.prototype.pathType = function (path) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  if (this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path)) {\n    return 'real';\n  } // Look for maps\n\n\n  const mapPath = getMapPath(this, path);\n\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n\n  return 'adhocOrUndefined';\n};\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\n\nSchema.prototype.hasMixedParent = function (path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n\n    if (path in this.paths && this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\n\n\nSchema.prototype.setupTimestamp = function (timestamps) {\n  const childHasTimestamp = this.childSchemas.find(withTimestamp);\n\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return !!ts;\n  }\n\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ? timestamps.currentTime : null;\n  const schemaAdditions = {};\n  this.$timestamps = {\n    createdAt: createdAt,\n    updatedAt: updatedAt\n  };\n\n  if (updatedAt && !this.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  if (createdAt && !this.paths[createdAt]) {\n    schemaAdditions[createdAt] = Date;\n  }\n\n  this.add(schemaAdditions);\n  this.pre('save', function (next) {\n    const timestampOption = get(this, '$__.saveOptions.timestamps');\n\n    if (timestampOption === false) {\n      return next();\n    }\n\n    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;\n    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;\n    const defaultTimestamp = currentTime != null ? currentTime() : (this.ownerDocument ? this.ownerDocument() : this).constructor.base.now();\n    const auto_id = this._id && this._id.auto;\n\n    if (!skipCreatedAt && createdAt && !this.get(createdAt) && this.isSelected(createdAt)) {\n      this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);\n    }\n\n    if (!skipUpdatedAt && updatedAt && (this.isNew || this.isModified())) {\n      let ts = defaultTimestamp;\n\n      if (this.isNew) {\n        if (createdAt != null) {\n          ts = this.$__getValue(createdAt);\n        } else if (auto_id) {\n          ts = this._id.getTimestamp();\n        }\n      }\n\n      this.set(updatedAt, ts);\n    }\n\n    next();\n  });\n\n  this.methods.initializeTimestamps = function () {\n    const ts = currentTime != null ? currentTime() : this.constructor.base.now();\n\n    if (createdAt && !this.get(createdAt)) {\n      this.set(createdAt, ts);\n    }\n\n    if (updatedAt && !this.get(updatedAt)) {\n      this.set(updatedAt, ts);\n    }\n\n    return this;\n  };\n\n  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;\n  const opts = {\n    query: true,\n    model: false\n  };\n  this.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);\n  this.pre('replaceOne', opts, _setTimestampsOnUpdate);\n  this.pre('update', opts, _setTimestampsOnUpdate);\n  this.pre('updateOne', opts, _setTimestampsOnUpdate);\n  this.pre('updateMany', opts, _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = currentTime != null ? currentTime() : this.model.base.now();\n    applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(), this.options, this.schema);\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n/*!\n * ignore. Deprecated re: #6405\n */\n\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ? self.paths[subpaths[0]] : 'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n\n      break;\n    } // ignore if its just a position segment: path.0.subpath\n\n\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = type === 'nested';\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n\n  if (val) {\n    return 'real';\n  }\n\n  if (isNested) {\n    return 'nested';\n  }\n\n  return 'adhocOrUndefined';\n}\n/*!\n * ignore\n */\n\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n/**\n * Adds a method call to the queue.\n *\n * ####Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\n\nSchema.prototype.queue = function (name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n/**\n * Defines a pre hook for the document.\n *\n * ####Example\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\n\nSchema.prototype.pre = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n\n    return this;\n  }\n\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n\n    return this;\n  }\n\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`);\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware http://mongoosejs.com/docs/middleware.html\n * @see kareem http://npmjs.org/package/kareem\n * @api public\n */\n\n\nSchema.prototype.post = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n\n    return this;\n  }\n\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n\n    return this;\n  }\n\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n/**\n * Registers a plugin for this schema.\n *\n * ####Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\n\nSchema.prototype.plugin = function (fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' + 'got \"' + typeof fn + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n\n  this.plugins.push({\n    fn: fn,\n    opts: opts\n  });\n  fn(this, opts);\n  return this;\n};\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](./guide.html#methods)\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\n\nSchema.prototype.method = function (name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n\n  return this;\n};\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n * @see Statics /docs/guide.html#statics\n */\n\n\nSchema.prototype.static = function (name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n\n  return this;\n};\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * ####Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\n\nSchema.prototype.index = function (fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n\n  return this;\n};\n/**\n * Sets/gets a schema option.\n *\n * ####Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\n\nSchema.prototype.set = function (key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n\n    case 'safe':\n      setSafe(this.options, value);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n\n      break;\n\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nconst safeDeprecationWarning = 'Mongoose: The `safe` option for schemas is ' + 'deprecated. Use the `writeConcern` option instead: ' + 'http://bit.ly/mongoose-write-concern';\nconst setSafe = util.deprecate(function setSafe(options, value) {\n  options.safe = value === false ? {\n    w: 0\n  } : value;\n}, safeDeprecationWarning);\n/**\n * Gets a schema option.\n *\n * ####Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key option name\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function (key) {\n  return this.options[key];\n};\n/**\n * The allowed index types\n *\n * @receiver Schema\n * @static indexTypes\n * @api public\n */\n\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function () {\n    return indexTypes;\n  },\n  set: function () {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()`\n * or by `index: true` in a path's options.\n *\n * ####Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function () {\n  return getIndexes(this);\n};\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @return {VirtualType}\n */\n\n\nSchema.prototype.virtual = function (name, options) {\n  if (name instanceof VirtualType) {\n    return this.virtual(name.path, name.options);\n  }\n\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function (obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n    const virtual = this.virtual(name);\n    virtual.options = options;\n    return virtual.get(function (_v) {\n      if (this.$$populatedVirtuals && this.$$populatedVirtuals.hasOwnProperty(name)) {\n        return this.$$populatedVirtuals[name];\n      }\n\n      if (_v == null) return undefined;\n      return _v;\n    }).set(function (_v) {\n      if (!this.$$populatedVirtuals) {\n        this.$$populatedVirtuals = {};\n      }\n\n      if (options.justOne || options.count) {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n\n        if (typeof this.$$populatedVirtuals[name] !== 'object') {\n          this.$$populatedVirtuals[name] = options.count ? _v : null;\n        }\n      } else {\n        this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function (doc) {\n          return doc && typeof doc === 'object';\n        });\n      }\n    });\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' + ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});\n    return mem[part];\n  }, this.tree); // Workaround for gh-8198: if virtual is under document array, make a fake\n  // virtual. See gh-8210\n\n  let cur = parts[0];\n\n  for (let i = 0; i < parts.length - 1; ++i) {\n    if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\n      const remnant = parts.slice(i + 1).join('.');\n      const v = this.paths[cur].schema.virtual(remnant);\n      v.get((v, virtual, doc) => {\n        const parent = doc.__parentArray[arrayParentSymbol];\n        const path = cur + '.' + doc.__index + '.' + remnant;\n        return parent.get(path);\n      });\n      break;\n    }\n\n    cur += '.' + parts[i + 1];\n  }\n\n  return virtuals[name];\n};\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\n\nSchema.prototype.virtualpath = function (name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * ####Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * @param {String|Array} path\n * @return {Schema} the Schema instance\n * @api public\n */\n\n\nSchema.prototype.remove = function (path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach(function (name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));\n\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n\n        _deletePath(this, name);\n\n        return;\n      }\n\n      delete this.paths[name];\n\n      _deletePath(this, name);\n    }, this);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](http://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](http://mongoosejs.com/docs/guide.html#statics), and\n * [methods](http://mongoosejs.com/docs/guide.html#methods).\n *\n * ####Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\n\n\nSchema.prototype.loadClass = function (model, virtualsOnly) {\n  if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model)); // Add static methods\n\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function (name) {\n      if (name.match(/^(length|name|prototype)$/)) {\n        return;\n      }\n\n      const method = Object.getOwnPropertyDescriptor(model, name);\n\n      if (typeof method.value === 'function') {\n        this.static(name, method.value);\n      }\n    }, this);\n  } // Add methods and virtuals\n\n\n  Object.getOwnPropertyNames(model.prototype).forEach(function (name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n\n    if (typeof method.get === 'function') {\n      this.virtual(name).get(method.get);\n    }\n\n    if (typeof method.set === 'function') {\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n  return this;\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._getSchema = function (path) {\n  const _this = this;\n\n  const pathschema = _this.path(path);\n\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          } // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n\n\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema;\n                } // comments.$.comments.$.title\n\n\n                ret = search(parts.slice(p + 1), foundschema.schema);\n\n                if (ret) {\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n                }\n\n                return ret;\n              } // this is the last path of the selector\n\n\n              ret = search(parts.slice(p), foundschema.schema);\n\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;\n              }\n\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n\n          const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n          return ret;\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n        return foundschema;\n      }\n    }\n  } // look for arrays\n\n\n  const parts = path.split('.');\n\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n\n  return search(parts, _this);\n};\n/*!\n * ignore\n */\n\n\nSchema.prototype._getPathType = function (path) {\n  const _this = this;\n\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return {\n              schema: foundschema,\n              pathType: 'mixed'\n            };\n          } // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n\n\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return {\n                  schema: foundschema,\n                  pathType: 'nested'\n                };\n              } // comments.$.comments.$.title\n\n\n              return search(parts.slice(p + 1), foundschema.schema);\n            } // this is the last path of the selector\n\n\n            return search(parts.slice(p), foundschema.schema);\n          }\n\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n\n        return {\n          schema: foundschema,\n          pathType: 'real'\n        };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return {\n          schema: schema,\n          pathType: 'nested'\n        };\n      }\n    }\n\n    return {\n      schema: foundschema || schema,\n      pathType: 'undefined'\n    };\n  } // look for arrays\n\n\n  return search(path.split('.'), _this);\n};\n/*!\n * ignore\n */\n\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n/*!\n * Module exports.\n */\n\n\nmodule.exports = exports = Schema; // require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * ####Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * ####Types:\n *\n * - [String](#schema-string-js)\n * - [Number](#schema-number-js)\n * - [Boolean](#schema-boolean-js) | Bool\n * - [Array](#schema-array-js)\n * - [Buffer](#schema-buffer-js)\n * - [Date](#schema-date-js)\n * - [ObjectId](#schema-objectid-js) | Oid\n * - [Mixed](#schema-mixed-js)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;","map":{"version":3,"sources":["C:/Users/Thakshan/Desktop/BookCorner/node_modules/mongoose/lib/schema.js"],"names":["EventEmitter","require","Kareem","MongooseError","SchemaType","SchemaTypeOptions","VirtualOptions","VirtualType","addAutoId","applyTimestampsToChildren","applyTimestampsToUpdate","arrayParentSymbol","get","getIndexes","handleTimestampOption","merge","mpath","readPref","ReadPreference","symbols","util","utils","validateRef","MongooseTypes","queryHooks","middlewareFunctions","documentHooks","hookNames","concat","reduce","s","hook","add","Set","id","Schema","obj","options","paths","aliases","subpaths","virtuals","singleNestedPaths","nested","inherits","callQueue","_indexes","methods","methodOptions","statics","tree","query","childSchemas","plugins","$id","hooks","defaultOptions","Array","isArray","definition","_idSubDoc","_id","isObject","auto_id","noId","setupTimestamp","timestamps","aliasFields","schema","Object","keys","path","prop","alias","Error","virtual","p","set","v","prototype","create","constructor","instanceOfSchema","defineProperty","configurable","enumerable","writable","clone","_userProvidedOptions","base","map","f","slice","call","gatherChildSchemas","$globalPluginsApplied","$isRootDiscriminator","$implicitlyCreated","discriminatorMapping","assign","discriminators","on","emit","pick","newSchema","schematype","safe","w","versionKey","baseOptions","strict","strictQuery","bufferCommands","capped","optimisticConcurrency","discriminatorKey","minimize","autoIndex","shardKey","read","validateBeforeSave","noVirtualId","typeKey","typePojoToMixed","prefix","key","fullPath","TypeError","length","isPOJO","substr","type","opts","_schema","schemaWrappedPath","addedKeys","reserved","listeners","removeListener","collection","errors","init","isModified","isNew","populated","remove","save","toObject","validate","warnings","increment","cleanPath","_pathToPositionalSyntax","undefined","_getPath","mapPath","getMapPath","hasMixedParent","test","getPositionalPath","firstPieceOfPath","split","console","log","hasUserDefinedProperty","ref","last","pop","branch","sub","msg","name","interpretAsType","schemaType","$isSchemaMap","_mapType","isInlineSchema","of","$__schemaType","$isSingleNested","value","caster","push","model","$isMongooseDocumentArray","casterConstructor","$isMongooseArray","arrayPath","_schemaType","toAdd","$embeddedSchemaType","_arrayPath","$isUnderneathDocArray","hasOwnProperty","replace","_path","includes","re","RegExp","Types","constructorName","getFunctionName","oldObj","Mixed","cast","DocumentArray","charAt","toUpperCase","substring","childSchemaOptions","childSchema","schemaName","Embedded","Buffer","isBuffer","toString","eachPath","fn","len","i","requiredPaths","invalidate","_requiredpaths","ret","isRequired","indexedPaths","_indexedpaths","indexes","pathType","getPositionalPathType","childHasTimestamp","find","withTimestamp","ts","createdAt","updatedAt","currentTime","schemaAdditions","$timestamps","Date","pre","next","timestampOption","skipUpdatedAt","skipCreatedAt","defaultTimestamp","ownerDocument","now","auto","isSelected","getTimestamp","$__getValue","initializeTimestamps","_setTimestampsOnUpdate","builtInMiddleware","getUpdate","self","filter","Boolean","val","isNested","subpath","queue","args","remainingArgs","arguments","apply","el","post","plugin","deduplicate","method","static","index","fields","expires","_tags","setSafe","safeDeprecationWarning","deprecate","indexTypes","localField","foreignField","has","_v","$$populatedVirtuals","justOne","count","unset","doc","parts","mem","part","cur","remnant","join","parent","__parentArray","__index","virtualpath","forEach","allKeys","startsWith","_deletePath","pieces","piece","loadClass","virtualsOnly","Function","getPrototypeOf","getOwnPropertyNames","match","getOwnPropertyDescriptor","_getSchema","_this","pathschema","resultPath","$fullPath","search","foundschema","trypath","isArrayFilter","_getPathType","endsWith","module","exports","ObjectId"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseError = require('./error/mongooseError');\nconst SchemaType = require('./schematype');\nconst SchemaTypeOptions = require('./options/SchemaTypeOptions');\nconst VirtualOptions = require('./options/VirtualOptions');\nconst VirtualType = require('./virtualtype');\nconst addAutoId = require('./helpers/schema/addAutoId');\nconst applyTimestampsToChildren = require('./helpers/update/applyTimestampsToChildren');\nconst applyTimestampsToUpdate = require('./helpers/update/applyTimestampsToUpdate');\nconst arrayParentSymbol = require('./helpers/symbols').arrayParentSymbol;\nconst get = require('./helpers/get');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst handleTimestampOption = require('./helpers/schema/handleTimestampOption');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst readPref = require('./driver').get().ReadPreference;\nconst symbols = require('./schema/symbols');\nconst util = require('util');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\n\nlet MongooseTypes;\n\nconst queryHooks = require('./helpers/query/applyQueryMiddleware').\n  middlewareFunctions;\nconst documentHooks = require('./helpers/model/applyHooks').middlewareFunctions;\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nlet id = 0;\n\n/**\n * Schema constructor.\n *\n * ####Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * ####Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [capped](/docs/guide.html#capped): bool - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - [minimize](/docs/guide.html#minimize): bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\n * - [shardKey](/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [typePojoToMixed](/docs/guide.html#typePojoToMixed) - boolean - defaults to true. Determines whether a type set to a POJO becomes a Mixed path or a Subdocument\n * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [storeSubdocValidationError](/docs/guide.html#storeSubdocValidationError): boolean - Defaults to true. If false, Mongoose will wrap validation errors in single nested document subpaths into a single validation error on the single nested subdoc's path.\n *\n * ####Options for Nested Schemas:\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * ####Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.methodOptions = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n\n  this.s = {\n    hooks: new Kareem()\n  };\n\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (!this.options.noId && this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/*!\n * Create virtual properties with alias field\n */\nfunction aliasFields(schema, paths) {\n  paths = paths || Object.keys(schema.paths);\n  for (const path of paths) {\n    const options = get(schema.paths[path], 'options');\n    if (options == null) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    const alias = options.alias;\n\n    if (!alias) {\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * ####Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * ####Example:\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * ####Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * ####Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = new Schema({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * ####Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {Array} paths list of paths to pick\n * @param {Object} [options] options to pass to the schema constructor. Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  if (options && options.safe === false) {\n    options.safe = { w: 0 };\n  }\n\n  if (options && options.safe && options.safe.w === 0) {\n    // if you turn off safe writes, then versioning goes off as well\n    options.versionKey = false;\n  }\n\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n\n  const baseOptions = get(this, 'base.options', {});\n  options = utils.options({\n    strict: 'strict' in baseOptions ? baseOptions.strict : true,\n    strictQuery: 'strictQuery' in baseOptions ? baseOptions.strictQuery : false,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    discriminatorKey: '__t',\n    minimize: true,\n    autoIndex: null,\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    noId: false, // deprecated, use { _id: false }\n    _id: true,\n    noVirtualId: false, // deprecated, use { id: false }\n    id: true,\n    typeKey: 'type',\n    typePojoToMixed: 'typePojoToMixed' in baseOptions ? baseOptions.typePojoToMixed : true\n  }, utils.clone(options));\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * ####Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema) {\n    merge(this, obj);\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n\n  for (const key of keys) {\n    const fullPath = prefix + key;\n\n    if (obj[key] == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + obj[key] + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && obj[key] === false) {\n      continue;\n    }\n    if (obj[key] instanceof VirtualType) {\n      this.virtual(obj[key]);\n      continue;\n    }\n\n    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + obj[key][0] + '\"');\n    }\n\n    if (!(utils.isPOJO(obj[key]) || obj[key] instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, obj[key]);\n    } else if (Object.keys(obj[key]).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, obj[key]); // mixed type\n    } else if (!obj[key][this.options.typeKey] || (this.options.typeKey === 'type' && obj[key].type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object { last: { name: String }}\n      this.nested[fullPath] = true;\n      this.add(obj[key], fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      if (!this.options.typePojoToMixed && utils.isPOJO(obj[key][this.options.typeKey])) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        }\n        // Propage `typePojoToMixed` to implicitly created schemas\n        const opts = { typePojoToMixed: false };\n        const _schema = new Schema(obj[key][this.options.typeKey], opts);\n        const schemaWrappedPath = Object.assign({}, obj[key], { [this.options.typeKey]: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, obj[key]);\n      }\n    }\n  }\n\n  const addedKeys = Object.keys(obj).\n    map(key => prefix ? prefix + key : key);\n  aliasFields(this, addedKeys);\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are rejected in schema declarations\n * because they conflict with Mongoose functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will throw\n * an error.\n *\n * - _posts\n * - _pres\n * - collection\n * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.on =\nreserved.removeListener =\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.schema =\nreserved.toObject =\nreserved.validate = 1;\n\n/*!\n * Document keys to print warnings for\n */\n\nconst warnings = {};\nwarnings.increment = '`increment` should not be used as a schema path name ' +\n    'unless you have disabled versioning.';\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * ####Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n  if (obj === undefined) {\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath]) {\n    throw new Error('`' + firstPieceOfPath + '` may not be used as a schema pathname');\n  }\n\n  if (warnings[path]) {\n    console.log('WARN: ' + warnings[path]);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n    let _mapType = { type: {} };\n    if (utils.hasUserDefinedProperty(obj, 'of')) {\n      const isInlineSchema = utils.isPOJO(obj.of) &&\n        Object.keys(obj.of).length > 0 &&\n        !utils.hasUserDefinedProperty(obj.of, this.options.typeKey);\n      _mapType = isInlineSchema ? new Schema(obj.of) : obj.of;\n    }\n    this.paths[mapPath] = this.interpretAsType(mapPath,\n      _mapType, this.options);\n    schemaType.$__schemaType = this.paths[mapPath];\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key in schemaType.schema.paths) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key in schemaType.schema.singleNestedPaths) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key in schemaType.schema.subpaths) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType = _schemaType.caster.clone();\n      }\n\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.subpaths[path + '.' + key] = schemaType.schema.paths[key];\n      schemaType.schema.paths[key].$isUnderneathDocArray = true;\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.subpaths[path + '.' + key] = schemaType.schema.subpaths[key];\n      schemaType.schema.subpaths[key].$isUnderneathDocArray = true;\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.subpaths[path + '.' + key] = schemaType.schema.singleNestedPaths[key];\n      schemaType.schema.singleNestedPaths[key].$isUnderneathDocArray = true;\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath)) {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  for (const _path of Object.keys(schema.paths)) {\n    if (!_path.includes('.$*')) {\n      continue;\n    }\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast\n      : type[0];\n\n    if (cast && cast.instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast[options.typeKey] || (options.typeKey === 'type' && cast.type.type))\n        && utils.isPOJO(cast)) {\n      if (Object.keys(cast).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (options.hasOwnProperty('typePojoToMixed')) {\n          childSchemaOptions.typePojoToMixed = options.typePojoToMixed;\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions &&\n            Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(cast, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See http://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Embedded(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'http://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  return new MongooseTypes[name](path, obj);\n};\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * ####Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * ####Example:\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * ####Example:\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (path in this.paths &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  const childHasTimestamp = this.childSchemas.find(withTimestamp);\n\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return !!ts;\n  }\n\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?\n    timestamps.currentTime :\n    null;\n  const schemaAdditions = {};\n\n  this.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n\n  if (updatedAt && !this.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  if (createdAt && !this.paths[createdAt]) {\n    schemaAdditions[createdAt] = Date;\n  }\n\n  this.add(schemaAdditions);\n\n  this.pre('save', function(next) {\n    const timestampOption = get(this, '$__.saveOptions.timestamps');\n    if (timestampOption === false) {\n      return next();\n    }\n\n    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;\n    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;\n\n    const defaultTimestamp = currentTime != null ?\n      currentTime() :\n      (this.ownerDocument ? this.ownerDocument() : this).constructor.base.now();\n    const auto_id = this._id && this._id.auto;\n\n    if (!skipCreatedAt && createdAt && !this.get(createdAt) && this.isSelected(createdAt)) {\n      this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);\n    }\n\n    if (!skipUpdatedAt && updatedAt && (this.isNew || this.isModified())) {\n      let ts = defaultTimestamp;\n      if (this.isNew) {\n        if (createdAt != null) {\n          ts = this.$__getValue(createdAt);\n        } else if (auto_id) {\n          ts = this._id.getTimestamp();\n        }\n      }\n      this.set(updatedAt, ts);\n    }\n\n    next();\n  });\n\n  this.methods.initializeTimestamps = function() {\n    const ts = currentTime != null ?\n      currentTime() :\n      this.constructor.base.now();\n    if (createdAt && !this.get(createdAt)) {\n      this.set(createdAt, ts);\n    }\n    if (updatedAt && !this.get(updatedAt)) {\n      this.set(updatedAt, ts);\n    }\n    return this;\n  };\n\n  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;\n\n  const opts = { query: true, model: false };\n  this.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);\n  this.pre('replaceOne', opts, _setTimestampsOnUpdate);\n  this.pre('update', opts, _setTimestampsOnUpdate);\n  this.pre('updateOne', opts, _setTimestampsOnUpdate);\n  this.pre('updateMany', opts, _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = currentTime != null ?\n      currentTime() :\n      this.model.base.now();\n    applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(),\n      this.options, this.schema);\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n\n/*!\n * ignore. Deprecated re: #6405\n */\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * ####Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the document.\n *\n * ####Example\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`);\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp} The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware http://mongoosejs.com/docs/middleware.html\n * @see kareem http://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * ####Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](./guide.html#methods)\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n * @see Statics /docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * ####Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets/gets a schema option.\n *\n * ####Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\nSchema.prototype.set = function(key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'safe':\n      setSafe(this.options, value);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst safeDeprecationWarning = 'Mongoose: The `safe` option for schemas is ' +\n  'deprecated. Use the `writeConcern` option instead: ' +\n  'http://bit.ly/mongoose-write-concern';\n\nconst setSafe = util.deprecate(function setSafe(options, value) {\n  options.safe = value === false ?\n    { w: 0 } :\n    value;\n}, safeDeprecationWarning);\n\n/**\n * Gets a schema option.\n *\n * ####Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key option name\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\n/**\n * The allowed index types\n *\n * @receiver Schema\n * @static indexTypes\n * @api public\n */\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()`\n * or by `index: true` in a path's options.\n *\n * ####Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType) {\n    return this.virtual(name.path, name.options);\n  }\n\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n    return virtual.\n      get(function(_v) {\n        if (this.$$populatedVirtuals &&\n          this.$$populatedVirtuals.hasOwnProperty(name)) {\n          return this.$$populatedVirtuals[name];\n        }\n        if (_v == null) return undefined;\n        return _v;\n      }).\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = options.count ? _v : null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  // Workaround for gh-8198: if virtual is under document array, make a fake\n  // virtual. See gh-8210\n  let cur = parts[0];\n  for (let i = 0; i < parts.length - 1; ++i) {\n    if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {\n      const remnant = parts.slice(i + 1).join('.');\n      const v = this.paths[cur].schema.virtual(remnant);\n      v.get((v, virtual, doc) => {\n        const parent = doc.__parentArray[arrayParentSymbol];\n        const path = cur + '.' + doc.__index + '.' + remnant;\n        return parent.get(path);\n      });\n      break;\n    }\n\n    cur += '.' + parts[i + 1];\n  }\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * ####Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * @param {String|Array} path\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](http://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](http://mongoosejs.com/docs/guide.html#statics), and\n * [methods](http://mongoosejs.com/docs/guide.html#methods).\n *\n * ####Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model));\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype)$/)) {\n        return;\n      }\n      const method = Object.getOwnPropertyDescriptor(model, name);\n      if (typeof method.value === 'function') {\n        this.static(name, method.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                    !foundschema.schema.$isSingleNested;\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n          const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n          return ret;\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * ####Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * ####Types:\n *\n * - [String](#schema-string-js)\n * - [Number](#schema-number-js)\n * - [Boolean](#schema-boolean-js) | Bool\n * - [Array](#schema-array-js)\n * - [Buffer](#schema-buffer-js)\n * - [Date](#schema-date-js)\n * - [ObjectId](#schema-objectid-js) | Oid\n * - [Mixed](#schema-mixed-js)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n"]},"metadata":{},"sourceType":"script"}